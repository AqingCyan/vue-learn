# 实例与生命周期
## 什么是实例
我们说了，Vue应用都应该从构建一个Vue实例开始。它管理着挂载在它身上的所有内容，因此实例是一个根实例，
所有的组件都应该挂载在根实例上面。创建一个Vue实例，需要通过new一个构造函数的方式，同时传入一个对象。
该对象可以传入很多内容，驱动页面的数据，模板，挂载的元素节点，方法，生命周期函数，子组件等。
```js
let vm = new Vue({
  el: '#app', // 挂载的元素
  data: {
    // 数据
  },
  methods: {
    // 方法
  },
  components: {
    // 挂载组件
  },
  ......
})
```
`vm`就是实例的变量名，我们可以在console控制台通过`vm`访问到我们创建的Vue实例。
## 属性与方法
每个Vue实例都会代理其data对象里的所有属性，并且让其作为驱动页面的数据。当data中的数据改变时，页面也会响应式的发生改变（响应式稍后讨论）。
```js
let data = { name: 'AqingCyan' }
let vm = new Vue({ 
  data: data
})
vm.a === data.a  // -> true
```
我们看到，把data作为vm实例中的data的属性值，它们其实是等价的。这里就体现出一个问题，修改外面的data对象，
也会影响到vm实例中的data。那么为了数据的安全，我们不建议把data定义在外面。
## 数据绑定页面的方法
既然data中的属性被vm实例代理，并且将作为驱动页面的数据，那该如何绑定到页面呢？
### 小胡子语法
小胡子语法是我们常用的绑定数据的方法。
以两个大括号开始，以两个大括号结尾，中间通常放data的属性（也可以放表达式，但除非特殊情况不建议这么操作），也就是将数据绑定到元素上。
```html
<div id="#app">
  <h1>{{name}}</h1>
  <h1>你好，我的名字是：{{name}}</h1>
   <!--也可以放入表达式-->
  <h1>{{1+1}}</h1>
</div>
```
假设id为app的节点已经被vm实例接管，这样写意为，`h1`标签被绑定了vm.data的name属性，
该标签在页面上应该是以一级标题显示的name的值。
### 响应式数据
当`data`的属性的值发生改变时，页面视图将会产生“响应”，即匹配更新为新的值。这个现象，我们称之为响应式数据。
**请打开控制台，执行`vm.name='HelloWorld'`观察页面的变化。** 另外，不止数据可以影响页面，页面反过来也可以影响数据，后面我们可以看到。
### 指令绑定
指令 (Directives) 是带有`v-`前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。
指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM。这里有几个指令常用语绑定数据到页面(**其他的以后细讲**)：
- `v-text`：直接写在DOM元素上，指令值是data中的属性，`<div v-text="message"></div>`与`<div>{{message}}</div>`是等价的。这里要提到一点，如果绑定的值是一个html标签，那么它是会被转义的。如果的确想展示的数据是被作为html模板编译过的话，请使用`v-html`
- `v-html`：与`v-text`一样的作用，但是与其不同的是，当我们绑定的数据是`<h1>123</h1>`的话，那么展示的数据会是一级标题格式的123。这么做具有风险，容易导致XSS攻击，Vue官方也写道只在可信内容上使用`v-html`，永不用在用户提交的内容上。
- `v-bind`：通常，我们需要在页面的元素上绑定data属性作为元素的属性的时候，就使用这个指令，这个指令很常用，基本在绑定属性的时候都会出现。它有一个简写`:属性名`，`<div :name="name"></div>`，这样写的含义就是，给div绑定一个name属性，它的属性值就是data中的name属性值。
- `v-for`：基于源数据多次渲染元素或者模板，前提是实例的data中提供的数据能够被遍历。`<li v-for="(item, index) in list">{{item}}</li>`，这么写的意为，遍历list，item是遍历的每一项，而index是遍历每一项的时候，它的索引值。这么遍历出来的内容，可以重复渲染`li`标签到页面上，但它的数据如何展示在于你的代码，示例用小胡子语法简单展示了item项。
- `v-model`：这是一个极具特点的指令，它提供了双向的数据绑定，通常用在用户输入的元素上，以做到页面与数据的相互影响。`<input v-model="content"/>`，input框会展示content的值，input的值改变，content的值也会改变。它的用处有很多，我们以后再讲。
:::tip
:warning:指令等号后面的内容，虽然用引号括起来，但并不是字符串，而是一个变量名或者其他，如果要让它的值是字符串的话，就要用不一样的引号包裹。
:ok_hand:`v-for`指令中，重复渲染的每一项都推荐添加一项key属性，这样有利于虚拟DOM的渲染，当然我们通常`:key="index"`这样给key赋值，这样做并不能对虚拟DOM的渲染起到性能提升的作用，如果你想了解虚拟DOM渲染与Diff算法，可以[看这里](#)。
:::
## 生命周期函数
> Vue生命周期函数就是Vue实例在某个时间点自动执行的函数，我们不必做太费力的理解，当做它们像衣架挂在杆子上，到时候成熟的时候，自然就触发了。
### 官方图解
![VueHook](https://cn.vuejs.org/images/lifecycle.png)
这其实是一个很明了的流程图，我们拆开来看流程（仅做理解，不够专业）。
1. 通过构造函数，创建了一个实例
2. 实例开始初始化，在初始化之前会执行`beforeCreate`函数
3. 实例初始化结束后，会执行`created`函数
4. 这个时候会做一个判断，要将实例挂载的元素根节点是否存在？如果存在的话，执行下一步，若没有，则等挂载元素的函数被调用
5. 接下来判断是否有模板设置？有的话就将模板放到`render`函数中，如果没有的话，就将挂载的根节点作为模板。
6. 现在开始挂载，在挂载之前，会自动执行`beforeMount`函数。之后就开始将实例挂载在元素节点上。
7. 在挂载后，自动执行`mounted`函数，这个时候，我们可以看到如果挂载后，数据发生变化，会促使两个函数`beforeUpdate`和`updated`自动执行，一个在重新渲染页面之前执行，一个重新渲染后执行。
8. 当实例被销毁的时候，也会在销毁前自动执行`beforeDestroy`函数和销毁之后的`destroyed`函数。
:::tip
请到源码仓库中的vue实例文件夹下，运行示例代码，阅读注释查看控制台打印，观察生命周期的自动执行。生命周期函数在特定时间自动执行，我们可以利用其在不同的时间段，处理不同的业务，例如可以在`mounted`中处理页面初次加载的ajax请求。
:::